spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    druid:
      initial-size: 5 
      max-active: 20
      min-idle: 5
      max-wait: 60000
      time-between-eviction-runs-millis: 60000
      min-evictable-idle-time-millis: 300000
      validation-query: SELECT 1 FROM DUAL
      test-while-idle: true
      test-on-borrow: false
      test-on-return: false
      pool-prepared-statements: true
      filter: stat,wall,log4j
      max-pool-prepared-statement-per-connection-size: 20
      use-global-data-source-stat: true
      connection-properties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500


sys:
  serviceName:
    send : 'haha-send'
    user : 'haha-user'
    business : 'haha-business'
  serviceContext:
    send : 'send'
    user : 'user'
    business : 'business'
    

token:
  except:
    url: /login/online,/login/out,/getSign,/user/createUser,/user/getLatestUsers,/article/getArticleList,/article/createArticle,/article/updateArticle

sign:
  except:
    url: /getSign,/user/checkAuth,/file/upload,/user/getLatestUsers
    
feign:
  client:
    config: 
      default:
        requestInterceptors:
          - com.yangy.common.interceptor.FeignHeaderInterceptor

#hystrix配置参考
#hystrix:
#  command:
#    #全局默认配置
#    default:
#      execution:
#        timeout:
#          #是否给方法执行设置超时时间，默认为true。一般我们不要改。
#          enabled: true
#        isolation:
#          #配置请求隔离的方式，这里是默认的线程池方式。还有一种信号量的方式semaphore，使用比较少。
#          strategy: threadPool
#          semaphore:
#            maxConcurrentRequests: 1000
#          thread:
#            #方式执行的超时时间，默认为1000毫秒，在实际场景中需要根据情况设置
#            timeoutInMilliseconds: 60000
#            #发生超时时是否中断方法的执行，默认值为true。不要改。
#            interruptOnTimeout: true
#            #是否在方法执行被取消时中断方法，默认值为false。没有实际意义，默认就好！
#            interruptOnCancel: false
#            #熔断器相关配置
#      ##并发执行的最大线程数，默认10
#      coreSize: 200
#      #说明：是否允许线程池扩展到最大线程池数量，默认为false。
#      allowMaximumSizeToDivergeFromCoreSize: true
#      #说明：线程池中线程的最大数量，默认值是10。此配置项单独配置时并不会生效，需要启用allowMaximumSizeToDivergeFromCoreSize
#      maximumSize: 200
#      #说明1：作业队列的最大值，默认值为-1。表示队列会使用SynchronousQueue，此时值为0，Hystrix不会向队列内存放作业。
#      #说明2：如果此值设置为一个正int型，队列会使用一个固定size的LinkedBlockingQueue，此时在核心线程池都忙碌的情况下，会将作业暂时存放在此队列内，但是超出此队列的请求依然会被拒绝
#      maxQueueSize: 20000
#      #设置队列拒绝请求的阀值，默认为5。
#      queueSizeRejectionThreshold: 30000
# 
#      circuitBreaker:
#        #说明：是否启动熔断器，默认为true。我们使用Hystrix的目的就是为了熔断器，不要改，否则就不要引入Hystrix。
#        enabled: true
#        #说明1：启用熔断器功能窗口时间内的最小请求数，假设我们设置的窗口时间为10秒，
#        #说明2：那么如果此时默认值为20的话，那么即便10秒内有19个请求都失败也不会打开熔断器。
#        #说明3：此配置项需要根据接口的QPS进行计算，值太小会有误打开熔断器的可能，而如果值太大超出了时间窗口内的总请求数，则熔断永远也不会被触发
#        #说明4：建议设置一般为：QPS*窗口描述*60%
#        requestVolumeThreshold: 3000
#        #说明1：熔断器被打开后，所有的请求都会被快速失败掉，但是何时恢复服务是一个问题。熔断器打开后，Hystrix会在经过一段时间后就放行一条请求
#        #说明2：如果请求能够执行成功，则说明此时服务可能已经恢复了正常，那么熔断器会关闭；相反执行失败，则认为服务仍然不可用，熔断器保持打开。
#        #说明3：所以此配置的作用是指定熔断器打开后多长时间内允许一次请求尝试执行，官方默认配置为5秒。
#        sleepWindowInMilliseconds: 5000
#        #说明1:该配置是指在通过滑动窗口获取到当前时间段内Hystrix方法执行失败的几率后，根据此配置来判断是否需要打开熔断器
#        #说明2:这里官方的默认配置为50，即窗口时间内超过50%的请求失败后就会打开熔断器将后续请求快速失败掉
#        errorThresholdPercentage: 70
#        #说明：是否强制启用熔断器，默认false，没有什么场景需要这么配置，忽略！
#        forceOpen: false
#        #说明：是否强制关闭熔断器，默认false，没有什么场景需要这么配置，忽略！
#        forceClosed: false
